12기 대전2반 B208 정윤선

부트캠프 주간

아이디어 해커톤
JPA 학습 (강의)


1주차

아이디어 구상
아이디어 회의
요구사항 정의서 작성
BackEnd 개발대비 JPA 학습



💡 아이디어 구상

(1) 개인별 맞춤 향수를 위한 "향수 큐레이션" 서비스



1. 기존 문제점

다양한 향수 정보 분산:
브랜드별, 향별 정보가 여러 사이트에 분산되어 있어 원하는 정보를 찾기 어려움.
새로운 향수나 나와 어울리는 향수를 추천받기 어렵고, 선택 과정에서 시간이 소요됨.

개인의 취향 반영 부족:
현재의 추천 서비스는 대중적인 인기 제품 위주로 구성되어 있으며, 개개인의 성격, 이미지, 분위기를 고려한 추천이 부족함.
퍼스널 컬러나 이미지 분석을 기반으로 한 향수 추천 서비스의 부재.


2. 타겟 사용자

향수 애호가:
자신만의 개성과 이미지를 잘 나타낼 수 있는 향수를 찾고 싶은 사람.
새로운 향수 정보를 빠르게 탐색하고, 관련 리뷰나 사용 경험을 공유하고 싶은 사람.

향수 입문자:
향수 선택이 처음이거나, 나와 어울리는 향수를 찾고 싶은 사람.
자신의 퍼스널 컬러, 이미지, 분위기와 어울리는 향수를 추천받고 싶은 사람.


3. 주요 기능

AI 기반 향수 추천

퍼스널 컬러, 성격, 이미지, 분위기를 분석해 개인 맞춤형 향수를 추천.
ex) "봄 웜톤", "활발하고 에너제틱한 이미지" 기반 추천.

유명 브랜드부터 니치 향수까지 폭넓은 데이터베이스 구축.

개인화된 향수 프로필 대시보드

사용자의 취향, 선호도를 기반으로 한 대시보드 제공.

"가장 선호하는 향 조합", "시트러스 계열 선호도" 등의 통계 시각화.

향수 사용 기록 저장 및 리뷰 작성 기능.

향수 비교 및 테스트 시뮬레이터

여러 향수를 비교 분석하여 사용자가 최적의 선택을 할 수 있도록 지원.

AR/VR을 활용한 향수 경험 시뮬레이터 제공 (향의 느낌을 시각적으로 표현).

향수 관련 콘텐츠 큐레이션

브랜드 신제품, 인기 향수, 추천 리뷰 등 개인화된 콘텐츠 제공.

좋아하는 브랜드나 향수 관련 뉴스, 트렌드 업데이트 자동 알림.

커뮤니티 및 소셜 기능

유저들이 향수 사용 경험, 리뷰를 공유하고 소통할 수 있는 커뮤니티 제공.

향별 토론 게시판, 리뷰 좋아요 및 댓글 기능.

"같은 향수를 사용하는 사람" 매칭 기능.

구매 연결 및 샘플 추천

추천 향수를 쉽게 구매할 수 있도록 공식 사이트나 신뢰할 수 있는 쇼핑몰 연결.

사용자가 선택한 향수와 비슷한 샘플 추천 및 소량 구매 서비스 제공.


4. 서비스의 기대 효과

개인화된 경험 제공: 사용자의 취향과 성향을 분석하여 맞춤형 향수 추천.
시간 절약: 다양한 정보를 한곳에 통합하여 향수 검색과 선택의 편리성 제공.
커뮤니티 활성화: 사용자 간 경험 공유를 통해 향수 팬덤 및 유대감 형성.
새로운 소비 트렌드 창출: AI와 개인화 기술을 결합한 새로운 향수 소비 경험 제공.





🪄 JPA 학습 내용 요약

## chapter 5

### 1. **연관관계 매핑의 목적**

- 객체와 테이블 간 **참조(객체)**와 **외래 키(테이블)**를 매핑.
- **용어 이해**:
    1. **방향**:
        - 단방향: 한쪽에서만 참조 가능.
        - 양방향: 양쪽에서 참조 가능.
    2. **다중성**:
        - 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M).
    3. **연관관계의 주인**:
        - 외래 키를 관리하는 주체.

---

### 2. **단방향 연관관계**

1. **객체 지향 모델링**:
    - 객체는 참조를 통해 연관된 데이터를 탐색.
    - 예제:
        
        ```java
        java
        복사편집
        @ManyToOne
        @JoinColumn(name = "TEAM_ID")
        private Team team;
        
        ```
        
2. **장점**:
    - 테이블 중심 설계보다 객체 지향적이며 명확한 연관관계 표현.
    - 객체 그래프 탐색이 가능:
        
        ```java
        java
        복사편집
        Team findTeam = findMember.getTeam();
        
        ```
        

---

### 3. **양방향 연관관계**

1. **구조**:
    - 단방향과 동일한 설정에 추가적으로 반대 방향 매핑 추가.
        
        ```java
        java
        복사편집
        @OneToMany(mappedBy = "team")
        private List<Member> members = new ArrayList<>();
        
        ```
        
2. **연관관계의 주인**:
    - 외래 키를 관리하는 객체를 지정.
    - 주인은 `mappedBy`를 사용하지 않으며, 비주인은 `mappedBy`로 주인 명시.
        
        ```java
        java
        복사편집
        @ManyToOne
        @JoinColumn(name = "TEAM_ID")
        private Team team; // 주인
        
        @OneToMany(mappedBy = "team")
        private List<Member> members; // 비주인
        
        ```
        
3. **주의점**:
    - 항상 **연관관계의 주인**에 값을 설정해야 함.
    - 순수 객체 상태를 고려해 양쪽 값을 모두 설정:
        
        ```java
        java
        복사편집
        team.getMembers().add(member);
        member.setTeam(team);
        
        ```
        

---

### 4. **연관관계 매핑 시 주의 사항**

1. **연관관계의 주인 설정 기준**:
    - 외래 키가 있는 위치를 기준으로 설정.
    - 비즈니스 로직을 기준으로 주인을 설정하지 않음.
2. **양방향 매핑 주의점**:
    - **무한 루프 방지**:
        - `toString()`, Lombok, JSON 생성 라이브러리 사용 시.
    - **편의 메서드 작성**:
        - 관계 설정을 명확히 하기 위해 사용:
            
            ```java
            java
            복사편집
            public void addMember(Member member) {
                members.add(member);
                member.setTeam(this);
            }
            
            ```
            

---

### 5. **단방향 vs 양방향**

- 단방향만으로 연관관계 매핑은 충분.
- 양방향은 객체 그래프 탐색을 위해 추가적 기능 제공.
- **JPQL**에서 역방향 탐색 시 양방향 매핑이 유용.

---

### 6. **실전 예제 요약**

1. **요구사항**:
    - 회원은 하나의 팀에 소속 (다대일 관계).
    - 팀은 여러 회원을 가짐 (일대다 관계).
2. **설계**:
    - 단방향 매핑으로 기본 구조 설계.
    - 필요 시 양방향 매핑 추가.



## chapter 6

### 1. **연관관계 매핑 시 고려사항**

1. **다중성**:
    - 다대일(N:1): `@ManyToOne`
    - 일대다(1:N): `@OneToMany`
    - 일대일(1:1): `@OneToOne`
    - 다대다(N:M): `@ManyToMany`
2. **단방향 vs 양방향**:
    - **단방향**: 한쪽에서만 참조 가능.
    - **양방향**: 양쪽에서 참조 가능. 테이블과 달리 객체는 방향 개념 존재.
3. **연관관계의 주인**:
    - 외래 키를 관리하는 엔티티를 지정.
    - 주인이 아닌 쪽은 읽기만 가능하며, `mappedBy`로 주인 지정.

---

### 2. **연관관계 매핑 종류**

1. **다대일 (N:1)**:
    - 가장 흔히 사용하는 매핑.
    - 예제:
        
        ```java
        java
        복사편집
        @ManyToOne
        @JoinColumn(name = "TEAM_ID")
        private Team team;
        
        ```
        
2. **일대다 (1:N)**:
    - 단방향:
        - `@JoinColumn`을 반드시 사용.
        - 성능상 비효율적이며, **다대일 양방향** 매핑을 권장.
    - 양방향:
        - 공식적으로 존재하지 않음. `@JoinColumn(insertable=false, updatable=false)`로 읽기 전용 구현 가능.
3. **일대일 (1:1)**:
    - 외래 키 위치:
        - **주 테이블**: JPA 매핑이 편리하며 주 테이블에서 대상 확인 가능.
        - **대상 테이블**: 데이터베이스 개발자 선호. 일대일을 일대다로 변경 가능.
    - 예제:
        
        ```java
        java
        복사편집
        @OneToOne
        @JoinColumn(name = "DELIVERY_ID")
        private Delivery delivery;
        
        ```
        
4. **다대다 (N:M)**:
    - 관계형 데이터베이스에서는 중간 테이블로 풀어냄.
    - JPA는 `@ManyToMany`로 편리하게 매핑 가능하지만 실무에서는 사용하지 않음.
    - 이유:
        - 중간 테이블에 추가 필드(예: 수량, 주문 시간)를 넣을 수 없음.
    - 해결 방법:
        - 중간 테이블을 엔티티로 승격하고 `@OneToMany`, `@ManyToOne`으로 매핑.

---

### 3. **연관관계 매핑 시 주요 어노테이션**

1. **`@JoinColumn`**:
    - 외래 키를 매핑.
    - 주요 속성:
        - `name`: 외래 키 이름 지정.
        - `referencedColumnName`: 참조 대상 테이블의 컬럼 이름.
        - `foreignKey`: 외래 키 제약 조건 설정 (DDL용).
2. **`@ManyToOne`, `@OneToMany`**:
    - 글로벌 페치 전략:
        - `@ManyToOne`: `FetchType.EAGER`(기본값).
        - `@OneToMany`: `FetchType.LAZY`(기본값).
    - `cascade`: 영속성 전이 기능.

---

### 4. **실전 예제**

1. **요구사항**:
    - 주문과 배송은 1:1 관계.
    - 상품과 카테고리는 N:M 관계.
2. **설계**:
    - N:M 관계를 1:N, N:1 관계로 풀어내 중간 테이블 엔티티 추가.
    - `@OneToOne`과 `@ManyToMany` 활용.

다대다: @ManyToMany (실무에서 사용 비권장).
